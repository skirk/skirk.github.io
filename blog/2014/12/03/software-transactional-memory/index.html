
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Concurrency & Parallelism -  locks  - Tuomo's corner</title>
	<meta name="author" content="Tuomo Rinne">

	
	<meta name="description" content="On my path to nirvana, I decided to detour to learn threading and concurrency. In this Concurrency &amp; Parallelism series I&rsquo;ll go through &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Tuomo's corner" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--  -->
<link href='http://fonts.googleapis.com/css?family=PT+Sans:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- Load jQuery -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript">
	jQuery.noConflict(); // ender.js conflicts with jQuery
</script>
<!-- Load FancyBox -->
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" />
<script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>
<!-- Fix FancyBox style for OctoPress -->
<style type="text/css">
  .fancybox-wrap { position: fixed !important; }
  .fancybox-opened {
    -webkit-border-radius: 4px !important;
       -moz-border-radius: 4px !important;
            border-radius: 4px !important;
  }
  .fancybox-close, .fancybox-prev span, .fancybox-next span {
    background-color: transparent !important;
    border: 0 !important;
  }
</style>

<!-- Custom Scripts -->
<script language="Javascript" type="text/javascript">
	// ender.js gobbles jQuery's ready event: Use ender.js $ instead
	$(document).ready(function() {
		jQuery(".fancybox").fancybox();
	});
</script> 

</head>

<body>
	<div class="container">	

		<div class="mid-col-container">
			<div id="content" class="inner">
				<div class="center"><a href="/"><img src="/images/loading_pacman2.gif"></a><a href="/about">&#8226 About </a><a href="/blog/archives">&#8226 Archive </a><a href="/contact">&#8226 Contact</a></div>
				<article class="post">
	<h1 class="title">Concurrency & Parallelism - Locks</h1>
	<div class="entry-content"><p>On my path to nirvana, I decided to detour to learn threading and concurrency. In this Concurrency &amp; Parallelism series I&rsquo;ll go through some fundamental concepts that is involved. Most of the information (that will be ) presented in the series is new information for me. Therefore, the act of writing will work as my parser which formats the information in sensible manner. Hopefully this will be useful for someone else as well.</p>

<h2>Basic Synchronization</h2>

<p>The usual solution to conduct interprocess synchronization is to use lock-based solutions such as <em>mutexes</em> where certain shared data elements are locked in mutually exclusive manner. The shared variable modifiable by multitude of threads is <em>locked</em> until a thread stops modifying the data. When finished the data is <em>unlocked</em>.</p>

<p> Another synchronization primitive is a <em>semaphore</em>. The semaphore is an integer value  which either grants or denies access to a shared variable. The semaphore is initiated with an absolute value, usually 0. When a process or a thread comes across a semaphore, a subtraction of 1 is taken from the value. If the value is negative, the process waits until a kernel grants it an access over the semaphore. Meanwhile a process waits for a unlock, another process has to add one to the semaphore to grant access for the waiting process.</p>

<p>Generally, mutexes are preferred over semaphores, because they enforce better code structure. Only single thread can lock and unlock mutex, whereas one thread can decrement semaphore and another increment <a href="#Kerrisk">(Kerrisk, 2010)</a>. Mutex and semaphore are collectively called <em>locks</em>. Using locks for synchronization has several problems:</p>

<p>One of them is <em>deadlock</em>, which is fairly easy to come across. The below image demonstrates 3 time steps, in which deadlock is achieved with two concurrent threads. Both of these threads will remain blocked indefinitely.</p>

<p><img src="/images/deadlock.svg"></p>

<p>A kernel scheduler can also interrupt thread execution, in a case where an higher-priority process starts executing on a thread instead. This is called <em>priority inversion</em>.</p>

<p>Lastly, <em>convoying</em> of processes occur, in which a <em>convoy</em> of processes queue at a sequence of locks <a href="#lockfree">(Fraser, 2004)</a>.</p>

<p>In the posts to come, I will look into lock-free synchronization.</p>

<h2>References</h2>

<ol class="bibliography"><li><span id="Kerrisk">Kerrisk, M. (2010). <i>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</i> (1 ed.). San Francisco, CA, USA: No Starch Press.</span></li>
<li><span id="lockfree">Fraser, K. (2004). <i>Practical lock-freedom</i>. Retrieved from http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf</span></li></ol>

</div>

</article>


			</div>
		</div>
		<footer id="footer" class="inner">
		Copyright &copy; 2015 

    <a href="/about">Tuomo Rinne</a>
 |
<span class="credit">Powered by <a href="http://octopress.org">Octopress</a>, customized with <a href="https://github.com/mjhea0/nologo">noLogo</a> + my own hacks</span>
</footer>
		<script src="/javascripts/slash.js"></script>








	</div>
</body>
</html>
